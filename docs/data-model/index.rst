Data Model
================================

.. toctree::

  overview
  model
  data-labels
  overlaps


The data model is entirely defined as XML, read in by org.intermine.modelproduction.xml.InterMineModelParser to a Model object. The Model is described by ClassDescriptors which in turn contain AttributeDescriptors, ReferenceDescriptors and CollectionDescriptors in org.intermine.model. All model code is in the intermine/objectstore project.

Model merging
-------------------------

The model for a Mine is usually made up from a core model and additions from sources, each of which is an extract of model XML. The merging is done by org.intermine.modelproduction.ModelMerger which checks for errors and inconsistencies.

Code & schema generation
-------------------------

Once the model is generated it is used to auto-generate Java classes and a database schema. Java code is generated by org.intermine.codegen.JavaModelOutput. Most 'classes' are actually interfaces as this allows multiple inheritance in the model, most of these interfaces inherit from org.intermine.model.InterMineObject which itself inherits from org.intermine.model.FastPathObect.  SimpleObjects extend directly from FastPathObject and are designed for faster loading but have fewer features.

The database schema is created by org.intermine.objectstore.intermine.TorqueModelOutput which creates an XML file for Apache Torque to create and SQL schema from, this should allow us to create a schema for other databases if ever required.

Building a database
-------------------------

When running ant build-db the model is merged, Java and schema are generated, the database is created from the schema and indexes are automatically created on id fields and foreign keys. The model XML is stored in the intermine_metadata table in the database by org.intermine.modelproduction.MetadataManager. Other operations, e.g. integrating data or deploying a webapp extract the model XML from the database and use it to construct a Model object.

Objects
-------------------------

Dynamic objects
~~~~~~~~~~~~~~~~~~~~

Objects in InterMine are a little complex because we require a data model composed of Java classes that supports multiple inheritance - Java classes don't allow multiple inheritance but a class can implement more than one interface. Objects from the data model are created by enhancing org.intermine.util.DynamicBean using a byte-code modification library called cglib. Essentially this creates an object on-the-fly without requiring a specific class but using a list of classes or interfaces (the exact details are hazy).

DynamicBean.intercept intercepts method calls on the created object so the final object appears to have getters and setters as in a normal bean, values are stored in a map in the object. This system was later updated to use org.intermine.model.ShadowClass to improve performance (I don't know the exact details) which provides getFieldValue and setFieldValue methods that avoid using reflection and are much faster at population fields.

Use DynamicUtil.createObject(Set<? extends Class<?>> classes) to create an InterMineObject.

Proxies
~~~~~~~~~~~~~~~~~~~~

In object/relational mapping systems when an object is read from the database we need to know which objects it is related to in order to follow references and collections. However, if the entire object were fetched each time and then it's referenced objects were fetched, etc one request could materialise millions of objects. e.g. if Gene references Organism and has a collection of Proteins we would fetch a Gene, it's Organism and Proteins then recusively fetch all references for the new objects.

Instead we use proxies. org.intermine.objectstore.proxy.ProxyReference appears to be a standard InterMineObject but in fact just contains an object id, when any method is called on the proxy the object is materialized automatically. e.g. Calling gene.getOrganism() returns a ProxyReference but calling gene.getOrganism().getName() de-referneces the proxy and returns the name.

org.intermine.objectstore.proxy.ProxyCollection does the same for collections but wraps an objectstore query required to populate the collection, the collection is materialised in batches as it is iterated over by wrapping a SingletonResults object.
